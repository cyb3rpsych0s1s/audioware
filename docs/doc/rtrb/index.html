<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="A realtime-safe single-producer single-consumer (SPSC) ring buffer."><title>rtrb - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-ca0dd0c4.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="rtrb" data-themes="" data-resource-suffix="" data-rustdoc-version="1.92.0 (ded5c06cf 2025-12-08)" data-channel="1.92.0" data-search-js="search-d69d8955.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../static.files/storage-e2aeef58.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-ce535bd0.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Crate rtrb</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../rtrb/index.html">rtrb</a><span class="version">0.3.2</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#examples" title="Examples">Examples</a></li></ul><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#enums" title="Enums">Enums</a></li><li><a href="#traits" title="Traits">Traits</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>rtrb</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/rtrb/lib.rs.html#1-821">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>A realtime-safe single-producer single-consumer (SPSC) ring buffer.</p>
<p>A <a href="struct.RingBuffer.html" title="struct rtrb::RingBuffer"><code>RingBuffer</code></a> consists of two parts:
a <a href="struct.Producer.html" title="struct rtrb::Producer"><code>Producer</code></a> for writing into the ring buffer and
a <a href="struct.Consumer.html" title="struct rtrb::Consumer"><code>Consumer</code></a> for reading from the ring buffer.</p>
<p>A fixed-capacity buffer is allocated on construction.
After that, no more memory is allocated (unless the type <code>T</code> does that internally).
Reading from and writing into the ring buffer is <em>lock-free</em> and <em>wait-free</em>.
All reading and writing functions return immediately.
Attempts to write to a full buffer return an error;
values inside the buffer are <em>not</em> overwritten.
Attempts to read from an empty buffer return an error as well.
Only a single thread can write into the ring buffer and a single thread
(typically a different one) can read from the ring buffer.
If the queue is empty, there is no way for the reading thread to wait
for new data, other than trying repeatedly until reading succeeds.
Similarly, if the queue is full, there is no way for the writing thread
to wait for newly available space to write to, other than trying repeatedly.</p>
<h2 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h2>
<p>Moving single elements into and out of a queue with
<a href="struct.Producer.html#method.push" title="method rtrb::Producer::push"><code>Producer::push()</code></a> and <a href="struct.Consumer.html#method.pop" title="method rtrb::Consumer::pop"><code>Consumer::pop()</code></a>, respectively:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>rtrb::{RingBuffer, PushError, PopError};

<span class="kw">let </span>(<span class="kw-2">mut </span>producer, <span class="kw-2">mut </span>consumer) = RingBuffer::new(<span class="number">2</span>);

<span class="macro">assert_eq!</span>(producer.push(<span class="number">10</span>), <span class="prelude-val">Ok</span>(()));
<span class="macro">assert_eq!</span>(producer.push(<span class="number">20</span>), <span class="prelude-val">Ok</span>(()));
<span class="macro">assert_eq!</span>(producer.push(<span class="number">30</span>), <span class="prelude-val">Err</span>(PushError::Full(<span class="number">30</span>)));

std::thread::spawn(<span class="kw">move </span>|| {
    <span class="macro">assert_eq!</span>(consumer.pop(), <span class="prelude-val">Ok</span>(<span class="number">10</span>));
    <span class="macro">assert_eq!</span>(consumer.pop(), <span class="prelude-val">Ok</span>(<span class="number">20</span>));
    <span class="macro">assert_eq!</span>(consumer.pop(), <span class="prelude-val">Err</span>(PopError::Empty));
}).join().unwrap();</code></pre></div>
<p>See the documentation of the <a href="chunks/index.html#examples" title="mod rtrb::chunks"><code>chunks</code></a> module
for examples that write multiple items at once with
<a href="struct.Producer.html#method.write_chunk_uninit" title="method rtrb::Producer::write_chunk_uninit"><code>Producer::write_chunk_uninit()</code></a> and <a href="struct.Producer.html#method.write_chunk" title="method rtrb::Producer::write_chunk"><code>Producer::write_chunk()</code></a>
and read multiple items with <a href="struct.Consumer.html#method.read_chunk" title="method rtrb::Consumer::read_chunk"><code>Consumer::read_chunk()</code></a>.</p>
</div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="chunks/index.html" title="mod rtrb::chunks">chunks</a></dt><dd>Writing and reading multiple items at once into and from a <a href="struct.RingBuffer.html" title="struct rtrb::RingBuffer"><code>RingBuffer</code></a>.</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Consumer.html" title="struct rtrb::Consumer">Consumer</a></dt><dd>The consumer side of a <a href="struct.RingBuffer.html" title="struct rtrb::RingBuffer"><code>RingBuffer</code></a>.</dd><dt><a class="struct" href="struct.Producer.html" title="struct rtrb::Producer">Producer</a></dt><dd>The producer side of a <a href="struct.RingBuffer.html" title="struct rtrb::RingBuffer"><code>RingBuffer</code></a>.</dd><dt><a class="struct" href="struct.RingBuffer.html" title="struct rtrb::RingBuffer">Ring<wbr>Buffer</a></dt><dd>A bounded single-producer single-consumer (SPSC) queue.</dd></dl><h2 id="enums" class="section-header">Enums<a href="#enums" class="anchor">§</a></h2><dl class="item-table"><dt><a class="enum" href="enum.PeekError.html" title="enum rtrb::PeekError">Peek<wbr>Error</a></dt><dd>Error type for <a href="struct.Consumer.html#method.peek" title="method rtrb::Consumer::peek"><code>Consumer::peek()</code></a>.</dd><dt><a class="enum" href="enum.PopError.html" title="enum rtrb::PopError">PopError</a></dt><dd>Error type for <a href="struct.Consumer.html#method.pop" title="method rtrb::Consumer::pop"><code>Consumer::pop()</code></a>.</dd><dt><a class="enum" href="enum.PushError.html" title="enum rtrb::PushError">Push<wbr>Error</a></dt><dd>Error type for <a href="struct.Producer.html#method.push" title="method rtrb::Producer::push"><code>Producer::push()</code></a>.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.CopyToUninit.html" title="trait rtrb::CopyToUninit">Copy<wbr>ToUninit</a></dt><dd>Extension trait used to provide a <a href="trait.CopyToUninit.html#tymethod.copy_to_uninit" title="method rtrb::CopyToUninit::copy_to_uninit"><code>copy_to_uninit()</code></a>
method on built-in slices.</dd></dl></section></div></main></body></html>