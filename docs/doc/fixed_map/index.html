<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="  "><title>fixed_map - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-6b053e98.ttf.woff2,FiraSans-Italic-81dc35de.woff2,FiraSans-Regular-0fe48ade.woff2,FiraSans-MediumItalic-ccf7e434.woff2,FiraSans-Medium-e1aa3f0a.woff2,SourceCodePro-Regular-8badfe75.ttf.woff2,SourceCodePro-Semibold-aa29a496.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2"href="../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../static.files/normalize-9960930a.css"><link rel="stylesheet" href="../static.files/rustdoc-ca0dd0c4.css"><meta name="rustdoc-vars" data-root-path="../" data-static-root-path="../static.files/" data-current-crate="fixed_map" data-themes="" data-resource-suffix="" data-rustdoc-version="1.92.0 (ded5c06cf 2025-12-08)" data-channel="1.92.0" data-search-js="search-d69d8955.js" data-stringdex-js="stringdex-c3e638e9.js" data-settings-js="settings-c38705f0.js" ><script src="../static.files/storage-e2aeef58.js"></script><script defer src="../crates.js"></script><script defer src="../static.files/main-ce535bd0.js"></script><noscript><link rel="stylesheet" href="../static.files/noscript-263c88ec.css"></noscript><link rel="alternate icon" type="image/png" href="../static.files/favicon-32x32-eab170b8.png"><link rel="icon" type="image/svg+xml" href="../static.files/favicon-044be391.svg"></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><rustdoc-topbar><h2><a href="#">Crate fixed_map</a></h2></rustdoc-topbar><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../fixed_map/index.html">fixed_<wbr>map</a><span class="version">0.9.5</span></h2></div><div class="sidebar-elems"><ul class="block"><li><a id="all-types" href="all.html">All Items</a></li></ul><section id="rustdoc-toc"><h3><a href="#">Sections</a></h3><ul class="block top-toc"><li><a href="#usage" title="Usage">Usage</a></li><li><a href="#features" title="Features">Features</a></li><li><a href="#specialized-storage-through-the-key-trait" title="Specialized storage through the `Key` trait">Specialized storage through the <code>Key</code> trait</a></li><li><a href="#why-does-this-crate-exist" title="Why does this crate exist?">Why does this crate exist?</a></li><li><a href="#unsafe-use" title="Unsafe use">Unsafe use</a></li><li><a href="#benchmarks" title="Benchmarks">Benchmarks</a></li><li><a href="#examples" title="Examples">Examples</a></li></ul><h3><a href="#modules">Crate Items</a></h3><ul class="block"><li><a href="#modules" title="Modules">Modules</a></li><li><a href="#structs" title="Structs">Structs</a></li><li><a href="#traits" title="Traits">Traits</a></li><li><a href="#derives" title="Derive Macros">Derive Macros</a></li></ul></section><div id="rustdoc-modnav"></div></div></nav><div class="sidebar-resizer" title="Drag to resize sidebar"></div><main><div class="width-limiter"><section id="main-content" class="content"><div class="main-heading"><h1>Crate <span>fixed_<wbr>map</span>&nbsp;<button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><rustdoc-toolbar></rustdoc-toolbar><span class="sub-heading"><a class="src" href="../src/fixed_map/lib.rs.html#1-488">Source</a> </span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p><a href="https://github.com/udoprog/fixed-map"><img alt="github" src="https://img.shields.io/badge/github-udoprog/fixed--map-8da0cb?style=for-the-badge&logo=github" height="20"></a>
<a href="https://crates.io/crates/fixed-map"><img alt="crates.io" src="https://img.shields.io/crates/v/fixed-map.svg?style=for-the-badge&color=fc8d62&logo=rust" height="20"></a>
<a href="https://docs.rs/fixed-map"><img alt="docs.rs" src="https://img.shields.io/badge/docs.rs-fixed--map-66c2a5?style=for-the-badge&logoColor=white&logo=data:image/svg+xml;base64,PHN2ZyByb2xlPSJpbWciIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDUxMiA1MTIiPjxwYXRoIGZpbGw9IiNmNWY1ZjUiIGQ9Ik00ODguNiAyNTAuMkwzOTIgMjE0VjEwNS41YzAtMTUtOS4zLTI4LjQtMjMuNC0zMy43bC0xMDAtMzcuNWMtOC4xLTMuMS0xNy4xLTMuMS0yNS4zIDBsLTEwMCAzNy41Yy0xNC4xIDUuMy0yMy40IDE4LjctMjMuNCAzMy43VjIxNGwtOTYuNiAzNi4yQzkuMyAyNTUuNSAwIDI2OC45IDAgMjgzLjlWMzk0YzAgMTMuNiA3LjcgMjYuMSAxOS45IDMyLjJsMTAwIDUwYzEwLjEgNS4xIDIyLjEgNS4xIDMyLjIgMGwxMDMuOS01MiAxMDMuOSA1MmMxMC4xIDUuMSAyMi4xIDUuMSAzMi4yIDBsMTAwLTUwYzEyLjItNi4xIDE5LjktMTguNiAxOS45LTMyLjJWMjgzLjljMC0xNS05LjMtMjguNC0yMy40LTMzLjd6TTM1OCAyMTQuOGwtODUgMzEuOXYtNjguMmw4NS0zN3Y3My4zek0xNTQgMTA0LjFsMTAyLTM4LjIgMTAyIDM4LjJ2LjZsLTEwMiA0MS40LTEwMi00MS40di0uNnptODQgMjkxLjFsLTg1IDQyLjV2LTc5LjFsODUtMzguOHY3NS40em0wLTExMmwtMTAyIDQxLjQtMTAyLTQxLjR2LS42bDEwMi0zOC4yIDEwMiAzOC4ydi42em0yNDAgMTEybC04NSA0Mi41di03OS4xbDg1LTM4Ljh2NzUuNHptMC0xMTJsLTEwMiA0MS40LTEwMi00MS40di0uNmwxMDItMzguMiAxMDIgMzguMnYuNnoiPjwvcGF0aD48L3N2Zz4K" height="20"></a></p>
<p>This crate provides a <a href="https://docs.rs/fixed-map/latest/fixed_map/map/struct.Map.html"><code>Map</code></a> and <a href="https://docs.rs/fixed-map/latest/fixed_map/set/struct.Set.html"><code>Set</code></a> container that can make use of a
pre-calculated backing storage. This enables the Rust compiler to heavily
optimize operations over them and avoid allocating.</p>
<p>See <a href="https://docs.rs/fixed-map">documentation</a> for information on how to use this crate.</p>
<br>
<h3 id="usage"><a class="doc-anchor" href="#usage">§</a>Usage</h3>
<p>Add <code>fixed-map</code> to your <code>Cargo.toml</code>:</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies]
fixed-map = &quot;0.9.5&quot;</code></pre></div>
<p>Anything used as a key in either a <a href="https://docs.rs/fixed-map/latest/fixed_map/map/struct.Map.html"><code>Map</code></a> or a <a href="https://docs.rs/fixed-map/latest/fixed_map/set/struct.Set.html"><code>Set</code></a> needs to implement
the <a href="https://docs.rs/fixed-map/latest/fixed_map/derive.Key.html"><code>Key</code></a> trait. This should be derived:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>fixed_map::{Key, Map};

<span class="attr">#[derive(Clone, Copy, Key)]
</span><span class="kw">enum </span>MyKey {
    North,
    South,
    East,
    West,
}</code></pre></div>
<p>After this you can use one of our containers:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>fixed_map::{Map, Set};

<span class="kw">let </span><span class="kw-2">mut </span>map = Map::new();
map.insert(MyKey::North, <span class="number">200</span>);
map.insert(MyKey::South, <span class="number">100</span>);

<span class="macro">assert_eq!</span>(map.get(MyKey::North), <span class="prelude-val">Some</span>(<span class="kw-2">&amp;</span><span class="number">200</span>));
<span class="macro">assert_eq!</span>(map.get(MyKey::East), <span class="prelude-val">None</span>);

<span class="kw">let </span><span class="kw-2">mut </span>set = Set::new();
set.insert(MyKey::North);
set.insert(MyKey::South);

<span class="macro">assert!</span>(set.contains(MyKey::South));
<span class="macro">assert!</span>(!set.contains(MyKey::East));</code></pre></div><br>
<h3 id="features"><a class="doc-anchor" href="#features">§</a>Features</h3>
<p>The following features are available:</p>
<ul>
<li><code>std</code> - Disabling this feature causes this crate to be no-std. This means
that dynamic types cannot be used in keys, like ones enabled by the <code>map</code>
feature (default).</li>
<li><code>hashbrown</code> - Causes <a href="https://docs.rs/fixed-map/latest/fixed_map/storage/trait.Storage.html"><code>Storage</code></a> to be implemented by dynamic types such
as <code>&amp;'static str</code> or <code>u32</code>. These are backed by a <code>hashbrown</code> (default).</li>
<li><code>entry</code> - Enables an <a href="https://docs.rs/fixed-map/latest/fixed_map/map/struct.Map.html#method.entry"><code>entry</code></a> API similar to that found on <a href="https://doc.rust-lang.org/stable/std/collections/hash_map/struct.HashMap.html#method.entry"><code>HashMap</code></a>.</li>
<li><code>serde</code> - Causes <a href="https://docs.rs/fixed-map/latest/fixed_map/map/struct.Map.html"><code>Map</code></a> and <a href="https://docs.rs/fixed-map/latest/fixed_map/set/struct.Set.html"><code>Set</code></a> to implement <a href="https://docs.rs/serde/1/serde/trait.Serialize.html"><code>Serialize</code></a> and
<a href="https://docs.rs/serde/1/serde/trait.Deserialize.html"><code>Deserialize</code></a> if it’s implemented by the key and value.</li>
</ul>
<br>
<h3 id="specialized-storage-through-the-key-trait"><a class="doc-anchor" href="#specialized-storage-through-the-key-trait">§</a>Specialized storage through the <a href="https://docs.rs/fixed-map/latest/fixed_map/derive.Key.html"><code>Key</code></a> trait</h3>
<p>The <a href="https://docs.rs/fixed-map/latest/fixed_map/derive.Key.html"><code>Key</code> derive</a> is provided to instruct our containers on how to build
optimized storage for a given <a href="https://docs.rs/fixed-map/latest/fixed_map/derive.Key.html"><code>Key</code></a>. We also require any key to be <a href="https://doc.rust-lang.org/std/marker/trait.Copy.html"><code>Copy</code></a>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>fixed_map::Key;

<span class="attr">#[derive(Clone, Copy, Key)]
</span><span class="kw">enum </span>MyKey {
    North,
    South,
    East,
    West,
}</code></pre></div>
<p>What happens behind the scenes is that a proc macro is used to build a
struct optimized for storing and indexing exactly 4 values - one for each
variant.</p>
<p>Something exactly like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">struct </span>Storage&lt;V&gt; {
    data: [<span class="prelude-ty">Option</span>&lt;V&gt;; <span class="number">4</span>],
}</code></pre></div>
<p>It becomes a bit more complicated once we start considering <em>composite
keys</em>. See the <a href="https://docs.rs/fixed-map/latest/fixed_map/derive.Key.html"><code>Key</code></a> documentation for more information.</p>
<br>
<h3 id="why-does-this-crate-exist"><a class="doc-anchor" href="#why-does-this-crate-exist">§</a>Why does this crate exist?</h3>
<p>There are many cases where you want associate a value with a small, fixed
number of elements identified by an enum.</p>
<p>Let’s say you have a game where each room has something in four directions.
We can model this relationship between the direction and the item using two
enums.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attr">#[repr(usize)]
</span><span class="kw">pub enum </span>Dir {
    North,
    East,
    South,
    West,
}

<span class="kw">pub enum </span>Item {
    Bow,
    Sword,
    Axe,
}</code></pre></div>
<p>The goal is for the performance of fixed map to be identical to storing the
data linearly in memory like you could through an array like <code>[Option&lt;Item&gt;; N]</code> where each <em>index</em> corresponds to a variant in <code>Dir</code>.</p>
<p>Doing this manually could look like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">let </span><span class="kw-2">mut </span>map: [<span class="prelude-ty">Option</span>&lt;Item&gt;; <span class="number">4</span>] = [<span class="prelude-val">None</span>, <span class="prelude-val">None</span>, <span class="prelude-val">None</span>, <span class="prelude-val">None</span>];
map[Dir::North <span class="kw">as </span>usize] = <span class="prelude-val">Some</span>(Item::Bow);

<span class="kw">if let </span><span class="prelude-val">Some</span>(item) = <span class="kw-2">&amp;</span>map[Dir::North <span class="kw">as </span>usize] {
    <span class="macro">println!</span>(<span class="string">"found item: {:?}"</span>, item);
}</code></pre></div>
<p>But with a fixed <a href="https://docs.rs/fixed-map/latest/fixed_map/map/struct.Map.html"><code>Map</code></a> you can do it idiomatically like this, without
incurring a drop in performance:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>fixed_map::{Key, Map};

<span class="attr">#[derive(Clone, Copy, Key)]
</span><span class="kw">pub enum </span>Dir {
    North,
    East,
    South,
    West,
}

<span class="attr">#[derive(Debug)]
</span><span class="kw">pub enum </span>Item {
    Bow,
    Sword,
    Axe,
}

<span class="kw">let </span><span class="kw-2">mut </span>map = Map::new();
map.insert(Dir::North, Item::Bow);

<span class="kw">if let </span><span class="prelude-val">Some</span>(item) = map.get(Dir::North) {
    <span class="macro">println!</span>(<span class="string">"found item: {:?}"</span>, item);
}</code></pre></div><br>
<h3 id="unsafe-use"><a class="doc-anchor" href="#unsafe-use">§</a>Unsafe use</h3>
<p>The Entry API uses <code>unwrap_unchecked</code> to obtain mutable references to the
inner value of <code>Some</code>s, and to skip <code>drop</code> when overwriting <code>None</code>s.</p>
<br>
<h3 id="benchmarks"><a class="doc-anchor" href="#benchmarks">§</a>Benchmarks</h3>
<p>We include benchmarks to ensure that we abide by the expectation that a
fixed map or set should perform roughly the same as an array with the same
number of elements.</p>
<p>In the following benchmarks fixed-map is compared to:</p>
<ul>
<li><code>fixed</code> - A <a href="https://docs.rs/fixed-map/latest/fixed_map/map/struct.Map.html"><code>Map</code></a> with a derived <a href="https://docs.rs/fixed-map/latest/fixed_map/derive.Key.html"><code>Key</code></a> with <code>N</code> variants.</li>
<li><a href="https://github.com/Amanieu/hashbrown"><code>hashbrown</code></a> - A high performance hash map. This is only included for
reference.
<ul>
<li>Note: Maps are created with <code>HashMap::with_capacity(N)</code>.</li>
</ul>
</li>
<li><code>array</code> - A simple <code>[Option&lt;Key&gt;; N]</code> array.</li>
</ul>
<p>Note: for all <code>insert</code> benchmarks the underlying storage is cloned in each
iteration.</p>
<div class="example-wrap"><pre class="language-text"><code>get/fixed/4             time:   [208.96 ps 209.57 ps 210.17 ps]
get/fixed/8             time:   [211.12 ps 211.86 ps 212.55 ps]
get/fixed/16            time:   [211.50 ps 211.84 ps 212.23 ps]
get/fixed/32            time:   [211.02 ps 211.40 ps 211.79 ps]
get/array/4             time:   [215.76 ps 216.56 ps 217.68 ps]
get/array/8             time:   [216.80 ps 217.28 ps 217.83 ps]
get/array/16            time:   [215.88 ps 216.21 ps 216.58 ps]
get/array/32            time:   [216.39 ps 216.82 ps 217.33 ps]
get/hashbrown/4         time:   [2.9134 ns 2.9168 ns 2.9210 ns]
get/hashbrown/8         time:   [2.9143 ns 2.9175 ns 2.9212 ns]
get/hashbrown/16        time:   [2.9258 ns 2.9293 ns 2.9328 ns]
get/hashbrown/32        time:   [2.9387 ns 2.9428 ns 2.9466 ns]

insert/fixed/4          time:   [421.82 ps 422.47 ps 423.22 ps]
insert/fixed/8          time:   [635.46 ps 636.91 ps 638.55 ps]
insert/fixed/16         time:   [1.0579 ns 1.0599 ns 1.0621 ns]
insert/fixed/32         time:   [1.6991 ns 1.7016 ns 1.7043 ns]
insert/array/4          time:   [419.26 ps 419.76 ps 420.30 ps]
insert/array/8          time:   [624.30 ps 626.27 ps 628.33 ps]
insert/array/16         time:   [1.0444 ns 1.0467 ns 1.0490 ns]
insert/array/32         time:   [1.6828 ns 1.6904 ns 1.6990 ns]
insert/hashbrown/4      time:   [87.002 ns 87.233 ns 87.475 ns]
insert/hashbrown/8      time:   [96.995 ns 97.287 ns 97.589 ns]
insert/hashbrown/16     time:   [517.89 ns 518.66 ns 519.57 ns]
insert/hashbrown/32     time:   [156.10 ns 156.67 ns 157.30 ns]

values/fixed/4          time:   [209.09 ps 209.51 ps 209.91 ps]
values/fixed/8          time:   [213.99 ps 215.34 ps 217.08 ps]
values/fixed/16         time:   [213.24 ps 213.94 ps 214.72 ps]
values/fixed/32         time:   [212.71 ps 213.82 ps 215.15 ps]
values/array/4          time:   [211.07 ps 211.78 ps 212.59 ps]
values/array/8          time:   [211.48 ps 212.03 ps 212.65 ps]
values/array/16         time:   [213.04 ps 213.49 ps 213.99 ps]
values/array/32         time:   [213.18 ps 213.78 ps 214.60 ps]
values/hashbrown/4      time:   [3.3965 ns 3.4007 ns 3.4056 ns]
values/hashbrown/8      time:   [3.8443 ns 3.8627 ns 3.8895 ns]
values/hashbrown/16     time:   [5.6312 ns 5.6666 ns 5.7029 ns]
values/hashbrown/32     time:   [8.7221 ns 8.7674 ns 8.8117 ns]

array/sum_values        time:   [3.0394 ns 3.0463 ns 3.0534 ns]
fixed/sum_values        time:   [3.0503 ns 3.0559 ns 3.0619 ns]</code></pre></div><br>
<h3 id="examples"><a class="doc-anchor" href="#examples">§</a>Examples</h3>
<p>Most examples are in place to test what kind of assembler they compile to.</p>
<p>To do this, run:</p>
<div class="example-wrap"><pre class="language-sh"><code>RUSTFLAGS=&quot;--emit asm&quot; cargo build --release --example &lt;example&gt;</code></pre></div>
<p>You should be able to find the assembler generated in the target folder:</p>
<div class="example-wrap"><pre class="language-sh"><code>ls target/release/examples/</code></pre></div></div></details><h2 id="modules" class="section-header">Modules<a href="#modules" class="anchor">§</a></h2><dl class="item-table"><dt><a class="mod" href="map/index.html" title="mod fixed_map::map">map</a></dt><dd>Contains the fixed <a href="struct.Map.html" title="struct fixed_map::Map"><code>Map</code></a> implementation.</dd><dt><a class="mod" href="raw/index.html" title="mod fixed_map::raw">raw</a></dt><dd>Raw access to underlying storage.</dd><dt><a class="mod" href="set/index.html" title="mod fixed_map::set">set</a></dt><dd>Contains the fixed <a href="struct.Set.html" title="struct fixed_map::Set"><code>Set</code></a> implementation.</dd></dl><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><dl class="item-table"><dt><a class="struct" href="struct.Map.html" title="struct fixed_map::Map">Map</a></dt><dd>A fixed map with storage specialized through the <a href="trait.Key.html" title="trait fixed_map::Key"><code>Key</code></a> trait.</dd><dt><a class="struct" href="struct.Set.html" title="struct fixed_map::Set">Set</a></dt><dd>A fixed set with storage specialized through the <a href="trait.Key.html" title="trait fixed_map::Key"><code>Key</code></a> trait.</dd></dl><h2 id="traits" class="section-header">Traits<a href="#traits" class="anchor">§</a></h2><dl class="item-table"><dt><a class="trait" href="trait.Key.html" title="trait fixed_map::Key">Key</a></dt><dd>The trait for a key that can be used to store values in a
<a href="struct.Set.html" title="struct fixed_map::Set"><code>Map</code></a> or <a href="struct.Set.html" title="struct fixed_map::Set"><code>Set</code></a>.</dd></dl><h2 id="derives" class="section-header">Derive Macros<a href="#derives" class="anchor">§</a></h2><dl class="item-table"><dt><a class="derive" href="derive.Key.html" title="derive fixed_map::Key">Key</a></dt><dd>Derive to implement the <a href="trait.Key.html" title="trait fixed_map::Key"><code>Key</code></a> trait.</dd></dl></section></div></main></body></html>